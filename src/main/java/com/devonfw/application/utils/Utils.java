package com.devonfw.application.utils;

import com.devonfw.application.model.BlacklistEntry;
import com.devonfw.application.model.ReflectionUsageEntry;
import com.opencsv.CSVParser;
import com.opencsv.CSVParserBuilder;
import com.opencsv.CSVReader;
import com.opencsv.CSVReaderBuilder;
import com.opencsv.exceptions.CsvValidationException;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;

/**
 * Supporting methods for processing the data and generating the decision support
 */
public class Utils {

    /**
     * Parses the CSV file generated by MTA in the first step, filters it and converts it to a list
     *
     * @param resultPath Path to the directory where the results will be saved
     * @return List with incompatible dependencies
     */
    public static List<List<String>> parseCSV(String resultPath) {

        Path csvFile = new File(resultPath + "\\AllIssues.csv").toPath();
        List<List<String>> records = new ArrayList<>();

        try {
            //Configure CSV parser
            Reader reader = Files.newBufferedReader(csvFile);

            CSVParser parser = new CSVParserBuilder()
                    .withSeparator(',')
                    .withIgnoreQuotations(true)
                    .build();

            CSVReader csvReader = new CSVReaderBuilder(reader)
                    .withSkipLines(1)
                    .withCSVParser(parser)
                    .build();

            //Save mandatory issues of csv file in list
            String[] values;
            while ((values = csvReader.readNext()) != null) {
                if (Arrays.asList(values).contains("mandatory") ||  Arrays.asList(values).contains("reflection")) {
                    records.add(Arrays.asList(values));
                }
            }

            //Delete MTA files
            //ToDo: Clean files

            // FileUtils.cleanDirectory(new File(resultPath));

        } catch (IOException | CsvValidationException e) {
            e.printStackTrace();
        }

        return records;
    }

    /**
     * Create directory for results
     *
     * @return Path to directory
     */
    public static String createDirectoryForResults() {

        Instant instant = Instant.now();
        long timeStampMillis = instant.toEpochMilli();
        String resultPath = System.getProperty("user.dir") + "\\results\\" + timeStampMillis;
        boolean mkdir = new File(resultPath).mkdirs();
        return resultPath;
    }

    /**
     * Converts output from CSV parser to blackList
     *
     * @param csvOutput Output from CSV parser
     * @return Blacklist
     */
    public static List<BlacklistEntry> generateBlacklist(List<List<String>> csvOutput) {

        List<BlacklistEntry> blackList = new ArrayList<>();

        csvOutput.forEach(entry -> {
            if (entry.get(1).equals("mandatory")) {
                String name = entry.get(0);
                String description = entry.get(2);

                //Searches for duplicate entries. MTA generates irrelevant duplicate entries
                boolean duplicateEntry = false;
                for (BlacklistEntry blacklistEntry : blackList) {
                    if (blacklistEntry.getRuleId().equals(name)) {
                        duplicateEntry = true;
                        break;
                    }
                }

                if (!duplicateEntry) {
                    blackList.add(new BlacklistEntry(name, description));
                }
            }
        });

        //Enhancing the found incompatibilities with the package names
        HashMap<String, String> packagesOfRules = Utils.resolvePackagesFromRules();
        blackList.forEach(blacklistEntry -> packagesOfRules.forEach((id, blacklistedPackage) -> {
            if (blacklistEntry.getRuleId().equals(id)) {
                blacklistEntry.setNameOfPackage(blacklistedPackage);
            }
        }));

        return blackList;
    }

    /**
     * Converts output from CSV parser to a list of reflection usage
     *
     * @param csvOutput Output from CSV parser
     * @return reflection usage list
     */
    public static List<ReflectionUsageEntry> generateReflectionUsageList(List<List<String>> csvOutput) {

        List<ReflectionUsageEntry> reflectionUsage = new ArrayList<>();

        csvOutput.forEach(entry -> {
            if (entry.get(1).equals("reflection")) {
                String nameOfClass = entry.get(6);
                String nameOfPackage = entry.get(7);

                reflectionUsage.add(new ReflectionUsageEntry(nameOfClass, nameOfPackage));
            }
        });

        return reflectionUsage;
    }

    /**
     * Parses the rules (xml-files) stored in the MTA and resolves the packages that belong to the rules.
     * @return Map with the rule ids and the corresponding packages
     */
    public static HashMap<String, String> resolvePackagesFromRules() {

        HashMap<String, String> packagesOfRules = new HashMap<>();

        File[] directories = new File(System.getProperty("user.dir") + "\\tools\\mta-cli-5.2.1\\rules\\migration-core\\quarkus").listFiles(File::isDirectory);

        for (File directory : directories) {
            File[] rules = new File(String.valueOf(directory)).listFiles();
            for (File rule : rules) {
                try {
                    String contentType = Files.probeContentType(Path.of(String.valueOf(rule)));
                    if (contentType != null && contentType.equals("text/xml")) {
                        SAXParserFactory saxParserFactory = SAXParserFactory.newDefaultInstance();
                        SAXParser saxParser = saxParserFactory.newSAXParser();
                        RuleXmlHandler ruleXmlHandler = new RuleXmlHandler(packagesOfRules);
                        saxParser.parse(rule, ruleXmlHandler);
                        packagesOfRules = ruleXmlHandler.getPackagesOfRules();
                    }
                } catch (IOException | ParserConfigurationException | SAXException e) {
                    e.printStackTrace();
                }
            }
        }

        return packagesOfRules;
    }

    /**
     * Handler class to parse the MTA rules
     */
    public static class RuleXmlHandler extends DefaultHandler {

        private final HashMap<String, String> packagesOfRules;
        private String insideRule = "";

        public RuleXmlHandler(HashMap<String, String> packagesOfRules) {

            this.packagesOfRules = packagesOfRules;
        }

        @Override
        public void startElement(String uri, String lName, String qName, Attributes attr) {

            if (qName.equals("rule") && insideRule.equals("")) {
                insideRule = attr.getValue("id");
                packagesOfRules.put(insideRule, "");
            } else if (qName.equals("dependency") && !insideRule.equals("")) {
                packagesOfRules.replace(insideRule, attr.getValue("groupId") + "." + attr.getValue("artifactId"));
            } else if (qName.equals("artifact") && !insideRule.equals("") && packagesOfRules.get(insideRule).equals("")) {
                packagesOfRules.replace(insideRule, attr.getValue("groupId") + "." + attr.getValue("artifactId"));
            } else if (qName.equals("javaclass") && !insideRule.equals("") && packagesOfRules.get(insideRule).equals("")) {
                packagesOfRules.replace(insideRule, attr.getValue("references"));
            }
        }

        @Override
        public void endElement(String uri, String localName, String qName) throws SAXException {

            if (qName.equals("rule")) {
                insideRule = "";
            }
        }

        public HashMap<String, String> getPackagesOfRules() {

            return packagesOfRules;
        }
    }
}
