package com.devonfw.application.util;

import com.devonfw.application.collector.AnalysisFailureCollector;
import com.devonfw.application.model.AnalysisFailureEntry;
import com.opencsv.CSVParser;
import com.opencsv.CSVParserBuilder;
import com.opencsv.CSVReader;
import com.opencsv.CSVReaderBuilder;
import com.opencsv.exceptions.CsvValidationException;
import org.apache.commons.io.FileUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.IOException;
import java.io.Reader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Utility class to parse CSV files
 */
public class CsvParser {

    private static final Logger LOG = LoggerFactory.getLogger(CsvParser.class);

    /**
     * This method parses the CSV file generated by MTA in the first step, filters it and converts it to a list
     *
     * @param resultPath Path to the directory where the results will be saved
     * @return List with incompatible dependencies
     */
    public static List<List<String>> parseCSV(String resultPath) {

        Path csvFile = Path.of(resultPath + File.separator + "AllIssues.csv");
        List<List<String>> records = new ArrayList<>();

        try {
            //Configure CSV parser
            Reader reader = Files.newBufferedReader(csvFile);

            CSVParser parser = new CSVParserBuilder()
                    .withSeparator(',')
                    .withEscapeChar('%')
                    .withIgnoreQuotations(true)
                    .build();

            CSVReader csvReader = new CSVReaderBuilder(reader)
                    .withSkipLines(1)
                    .withCSVParser(parser)
                    .build();

            //Save mandatory issues of csv file in list
            String[] values;
            while ((values = csvReader.readNext()) != null) {
                if (Arrays.asList(values).contains("mandatory") || Arrays.asList(values).contains("reflection")) {
                    records.add(Arrays.asList(values));
                }
            }

            //Delete MTA files after parsing
            FileUtils.cleanDirectory(new File(resultPath));

        } catch (IOException e) {
            AnalysisFailureCollector.addAnalysisFailure(new AnalysisFailureEntry(resultPath,
                    "The directory could not be cleaned after parsing the CSV file. This could lead to the interference of further analysis."));
            LOG.debug("Could not clean directory after parsing", e);
        } catch (CsvValidationException e) {
            AnalysisFailureCollector.addAnalysisFailure(
                    new AnalysisFailureEntry("", "Not all csv entries could be parsed"));
            LOG.debug("Could not read entry of csv file", e);
        }

        return records;
    }
}
